
make the neccesary corrections to the frontend code // Utility: Parse date string into local midnight
function toLocalMidnight(dateStr) {
  const [year, month, day] = dateStr.split("-").map(Number);
  return new Date(year, month - 1, day, 0, 0, 0);
}

// POST: Handle booking submission
function doPost(e) {
  Logger.log("--- New doPost Execution ---");

  if (!e || !e.postData || !e.postData.contents) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: "No POST data received."
    })).setMimeType(ContentService.MimeType.JSON);
  }

  let data;
  try {
    data = JSON.parse(e.postData.contents);
    Logger.log("Received data: " + JSON.stringify(data));
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: "Invalid JSON: " + error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }

  const { name, email, delivery_date, pickup_date, time } = data;
  if (!name || !email || !delivery_date || !pickup_date || !time) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: "Missing required fields."
    })).setMimeType(ContentService.MimeType.JSON);
  }

  const calendarId = "afde913e0bbb5c4de2f42b45187802ba8b49f3b4d5fcba1ab41938ced5fc1ecc@group.calendar.google.com";
  const calendar = CalendarApp.getCalendarById(calendarId);
  if (!calendar) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: "Calendar not found."
    })).setMimeType(ContentService.MimeType.JSON);
  }

  try {
    const startDate = toLocalMidnight(delivery_date);
    const endDate = toLocalMidnight(pickup_date);
    endDate.setDate(endDate.getDate() + 1); // Include full pickup day

    Logger.log("Booking request from " + startDate.toISOString().slice(0, 10) + " to " + endDate.toISOString().slice(0, 10));

    const overlappingRentals = calendar.getEvents(startDate, endDate).length;
    Logger.log("Rentals overlapping with request: " + overlappingRentals);

    if (overlappingRentals >= 3) {
      return ContentService.createTextOutput(JSON.stringify({
        status: "fully_booked",
        message: "We're fully booked for the requested dates. Please choose different ones."
      })).setMimeType(ContentService.MimeType.JSON);
    }

    calendar.createEvent(Dumpster Booking: ${name}, startDate, endDate, {
      description: Client: ${name}\nEmail: ${email}\nDelivery: ${delivery_date} at ${time}\nPickup: ${pickup_date}
    });

    return ContentService.createTextOutput(JSON.stringify({
      status: "booked",
      message: Dumpster successfully booked from ${delivery_date} to ${pickup_date}.
    })).setMimeType(ContentService.MimeType.JSON);

  } catch (error) {
    Logger.log("Error: " + error.message);
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// GET: Check availability for a date range
function doGet(e) {
  Logger.log("--- New doGet Execution ---");

  const calendarId = "afde913e0bbb5c4de2f42b45187802ba8b49f3b4d5fcba1ab41938ced5fc1ecc@group.calendar.google.com";
  const calendar = CalendarApp.getCalendarById(calendarId);
  if (!calendar) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: "Calendar not found."
    })).setMimeType(ContentService.MimeType.JSON);
  }

  const start = e.parameter.start;
  const end = e.parameter.end;

  if (!start || !end) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: "Missing 'start' or 'end' parameters."
    })).setMimeType(ContentService.MimeType.JSON);
  }

  try {
    const startDate = toLocalMidnight(start);
    const endDate = toLocalMidnight(end);
    endDate.setDate(endDate.getDate() + 1); // Include full pickup day

    const overlapping = calendar.getEvents(startDate, endDate).length;

    return ContentService.createTextOutput(JSON.stringify({
      status: "ok",
      overlapping
    })).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      status: "error",
      message: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}
